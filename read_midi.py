from music21 import *
import numpy as np

class MyMidi():
    def __init__(self, file):
        self.file = file
        self.show_instrument()

    def show_instrument(self):
        notes=[]
        notes_to_parse = None
        #parsing a midi file
        midi = converter.parse(self.file)
    
        #grouping based on different instruments
        s2 = instrument.partitionByInstrument(midi)

        for part in s2.parts:
            print(str(part))

    def read_midi(self, ins):

        #ins(str): selected instrument
        file = self.file
        print("Loading Music File:",file)
        
        notes=[]
        notes_to_parse = None
        
        #parsing a midi file
        midi = converter.parse(file)
    
        #grouping based on different instruments
        s2 = instrument.partitionByInstrument(midi)

        #Looping over all the instruments
        for part in s2.parts:
            print("selected instrument:",str(part))
            if ins in str(part): 
            
                notes_to_parse = part.recurse() 
        
                #finding whether a particular element is note or a chord
                for element in notes_to_parse:
                    
                    #note
                    if isinstance(element, note.Note):
                        notes.append(str(element.pitch))
                    
                    #chord
                    elif isinstance(element, chord.Chord):
                        notes.append('.'.join(str(n) for n in element.normalOrder))
        notes = np.array(notes)
        unique_x = list(set(notes.ravel()))
        self.x_note_to_int = dict((notes, number) for number, notes in enumerate(unique_x))
        self.x_int_to_note = dict((number, note_) for number, note_ in enumerate(unique_x))
        x_seq=[]
        for i in notes:
            #assigning unique integer to every note
            x_seq.append(self.x_note_to_int[i])
        return x_seq

    def convert_to_midi(self, predictions, fname):
        prediction_output = [self.x_int_to_note[i] for i in predictions]
        offset = 0
        output_notes = []

        # create note and chord objects based on the values generated by the model
        for pattern in prediction_output:
            
            # pattern is a chord
            if ('.' in pattern) or pattern.isdigit():
                notes_in_chord = pattern.split('.')
                notes = []
                for current_note in notes_in_chord:
                    
                    cn=int(current_note)
                    new_note = note.Note(cn)
                    new_note.storedInstrument = instrument.Piano()
                    notes.append(new_note)  
                    
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
                
            # pattern is a note
            else:
                
                new_note = note.Note(pattern)
                new_note.offset = offset
                new_note.storedInstrument = instrument.Piano()
                output_notes.append(new_note)

            # increase offset each iteration so that notes do not stack
            offset += 1
        midi_stream = stream.Stream(output_notes)
        midi_stream.write('midi', fp=fname)